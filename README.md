SEMUA TUGAS DARI PERTEMUAN PERTAMA SAMPAI TERAKHIR SAYA TARUH JADI SATU DISINI.

**Tugas Sistem Operasi Pertemuan Pertama**

1.	Apa hubungan antara perangkat lunak aplikasi dan sistem operasi?

Sistem Operasi adalah perangkat lunak yang mengatur aktivitas komputer secara keseluruhan, sedangkan aplikasi adalah perangkat lunak yang ditulis untuk melakukan tugas-tugas spesifik dan berjalan di atas sistem operasi. Dengan demikian, sistem operasi menyediakan platform dasar untuk menjalankan perangkat lunak aplikasi. Sistem operasi mengatur sumber daya komputer dan memberikan lingkungan di mana aplikasi dapat berjalan dan digunakan oleh pengguna.

2.	Apa yang dimaksud dengan sistem operasi? Apakah itu perangkat keras atau perangkat lunak?

Sistem Operasi adalah perangkat lunak yang bertindak sebagai penghubung antara pengguna dan perangkat keras komputer. Sistem operasi memungkinkan pengguna untuk berkomunikasi dengan perangkat keras dan menjalankan fungsi yang diinginkan. Dengan adanya sistem operasi maka pengguna dapat berkomunikasi dengan perangkat seperti laptop.

3.	Sebutkan fungsi utama suatu sistem operasi!

Enam fungsi utama sistem operasi:

a.	Fungsi Sistem Operasi sebagai Kordinator, yang memberikan fasilitas sehingga segala aktivitas yang kompleks dapat dikerjakan dalam urutan yang benar.

b.	Fungsi Sistem Operasi sebagai Pengawal, yang memegang kendali proses untuk melindungi file dan memberi batasan pada pembacaan, penulisan, eksekusi data dan program.

c.	Fungsi Sistem Operasi sebagai penjaga gerbang, yang akan mengawasi siapa saja yang dapat masuk kedalam sistem komputer.

d.	Fungsi Sistem Operasi sebagai pengoptimal, yang akan membuat scedule atas beberapa masukan pengguna, akses basis data, komputasi, keluaran, dan lain sebagainya untuk meningkatkan kinerja sistem.

e.	Fungsi Sistem Operasi sebagai akuntan, yang menjaga pewaktuan CPU tetap berada pada jalur yang benar, penggunaan memori, operasi I/O, penyimpanan pada disk dan lain sebagainya.

f.	Fungsi Sistem Operasi sebagai server, yang memberikan pelayanan yang diperlukan pengguna, seperti restrukturisasi direktori file.

4.	Jelaskan secara singkat evolusi sistem operasi!

a.	Generasi Awal (1945-1955)
Generasi pertama merupakan awal perkembangan sistem komputasi elektronik sebagai pengganti sistem komputasi mekanik. Hal itu disebabkan kecepatan manusia untuk menghitung terbatas. Selain itu manusia sangat mudah untuk membuat kecerobohan, kekeliruan bahkan kesalahan. Pada generasi ini belum ada sistem operasi, maka sistem komputer diberi instruksi yang harus dikerjakan secara langsung oleh pengguna.

b.	Generasi Kedua (1956-1964)
Pada generasi ini memperkenalkan Batch Processing System, yaitu Job yang dikerjakan dalam satu rangkaian, lalu dieksekusi secara berurutan. Generasi ini sistem komputer belum dilengkapi sistem operasi. Tetapi beberapa fungsi sistem operasi telah ada, contohnya fungsi sistem operasi ialah FMS dan IBSYS.

c.	Generasi Ketiga (1964-1979)
Sistem operasi pada generasi ini dikembangkan untuk melayani banyak pengguna, jadi para pengguna berkomunikasi lewat terminal secara on-line ke komputer. Sistem operasi menjadi multi-user (digunakan oleh banyak pengguna sekaligus), multi-programming (melayani banyak program sekaligus) dan multi tasking (melayani banyak tugas dan pekerjaan).

d.	Generasi Keempat (1979-Sekarang)
Generasi keempat ditandai dengan munculnya komputer pribadi dan workstation. Miniaturisasi sirkuit elektronik berlanjut dengan penggunaan teknologi Very Large Scale Integration (VLSI), yang memungkinkan pengembangan komputer desktop dengan kemampuan yang lebih besar. Sistem operasi seperti DOS Microsoft untuk komputer pribadi dan UNIX untuk workstation mulai mendominasi. Komputer desktop ini sering terhubung dalam sistem jaringan atau terdistribusi, dengan kemampuan login dari jarak jauh dan transfer informasi antar mesin. Mesin dalam sistem terdistribusi dianggap sebagai sistem prosesor tunggal virtual bagi pengguna, dengan sistem operasi pusat mengontrol lokasi dan sistem file yang mengelola program tertentu.

5.	Apa saja elemen kunci dari sistem operasi?

Elemen kunci dari sistem operasi meliputi:

a.	Manajemen sumber daya: Sistem operasi mengelola sumber daya terkait dengan pengendalian perangkat lunak system atau perangkat lunak aplikasi yang sedang dijalankan. 

b.	Pengaturan sistem kerja perangkat keras: Sistem operasi mengatur dan mengontrol perangkat keras komputer seperti hard disk, printer, keyboard, dan mouse.

c.	Penyediaan fasilitas dan layanan untuk para pemrogram: Sistem operasi menyediakan berbagai fasilitas dan layanan seperti editor dan debugger untuk membantu para pemrogram dalam membuat program.

d.	Alokasi ruang memori dan sumber daya lainnya secara sistematis: Sistem operasi mengalokasikan ruang memori dan sumber daya lainnya secara sistematis untuk memastikan setiap program dan aplikasi memiliki akses ke sumber daya yang diperlukan.

e.	Keamanan sistem komputer: Sistem operasi juga bertanggung jawab menjaga keamanan sistem komputer dengan memberikan akses yang terbatas pada pengguna dan memastikan program serta aplikasi yang dijalankan tidak merusak system.

6.	Apa yang Anda maksud dengan istilah generasi komputer?

Generasi komputer adalah istilah yang digunakan untuk menggambarkan perkembangan teknologi komputer dari waktu ke waktu. Perkembangan ini dibagi menjadi beberapa generasi, dimulai dari generasi pertama hingga generasi kelima. Setiap generasi memiliki ciri khas dan teknologi yang berbeda-beda. Generasi pertama komputer menggunakan tabung vakum untuk menyimpan data dan ukurannya memakan satu ruangan. Generasi kedua dimulai ketika transistor menggantikan tabung vakum. Generasi ketiga ditandai dengan pengembangan integrated circuit, sedangkan generasi keempat memiliki terobosan berupa mikroprosesor yang dapat menyatukan ribuan IC ke dalam sebuah keping. Generasi kelima saat ini ditandai dengan munculnya teknologi AI dan quantum computing. Setiap generasi komputer memiliki peran penting dalam perkembangan teknologi komputer yang kita kenal saat ini.

7.	Siapa yang memberikan gambaran tentang program tersimpan dan pada tahun berapa? Siapa yang memberikan struktur dasar komputer?

Program tersimpan pertama kali diperkenalkan oleh John von Neumann pada tahun 1946. John von Neumann juga memberikan struktur dasar komputer yang meliputi unit masukan (Input Unit), unit kontrol (Control Unit), unit logika dan aritmatika (Arithmetic & Logical Unit / ALU), unit memori/penyimpanan (Memory / Storage Unit), dan unit keluaran (Output Unit) Central Processing Unit (CPU) terdiri dari Control Unit dan ALU. 

8.	Sebutkan kekurangan komputer generasi pertama dibandingkan komputer generasi kedua!

Kekurangan Komputer Generasi Pertama dibandingkan dengan Komputer Generasi Kedua:

a. Ukuran Fisik: komputer generasi pertama memiliki dimensi yang sangat besar, memerlukan ruang yang luas, seukuran kamar tidur, tidak efisien dalam tata letak dan tidak cocok untuk penggunaan pribadi.

b. Konsumsi Listrik: komputer generasi pertama memerlukan daya listrik yang sangat besar untuk dioperasikan, menyebabkan konsumsi energi yang tinggi.

c. Pemakaian Rumit: pengoperasian komputer generasi pertama hanya bisa dilakukan menggunakan bahasa mesin yang rumit, tidak seperti komputer generasi kedua yang sudah menggunakan bahasa assembly.

d. Penggunaan Terbatas: komputer generasi pertama lebih banyak digunakan untuk kepentingan bisnis dan tidak cocok untuk penggunaan personal seperti saat ini.

e. Hanya Dimiliki oleh Kalangan Terbatas: keterbatasan dalam kepemilikan komputer generasi pertama hanya terbatas pada kalangan tertentu, tidak seperti saat ini di mana komputer lebih mudah diakses oleh semua orang.

9.	Berdasarkan sistem manakah komputer generasi kedua? Apa saja penemuan baru pada komputer generasi kedua?

Komputer generasi kedua menggunakan transistor sebagai pengganti tabung hampa (vacuum tube) pada komputer generasi pertama. Selain itu, pada komputer generasi kedua juga ditemukan memori inti-magnetikyang mampu mengembangkan komputer dengan lebih cepat. Beberapa penemuan baru pada komputer generasi kedua antara lain:

a. Penggunaan Transistor: Transistor digunakan sebagai pengganti tabung hampa pada komputer generasi pertama. Transistor lebih kecil, lebih andal, dan lebih hemat energi daripada tabung hampa.

b. Bahasa Pemrograman: Pada komputer generasi kedua, bahasa pemrograman tingkat tinggi seperti COBOL, ALGOL, dan FORTRAN mulai digunakan.

c. Kapasitas Penyimpanan: Kapasitas penyimpanan pada komputer generasi kedua lebih luas berkat penggunaan teknologi magnetic core storage (inti magnetik).

d. Efisiensi Energi: Daya listrik yang dibutuhkan oleh komputer generasi kedua lebih kecil dari komputer generasi pertama.

e. Orientasi Aplikasi: Komputer generasi kedua berorientasi pada aplikasi bisnis dan teknik, berbeda dengan komputer generasi pertama yang hanya fokus pada aplikasi bisnis saja.

10. Deskripsikan apa itu IC atau sirkuit terpadu!

Sirkuit terpadu atau Integrated Circuit (IC) adalah sebuah komponen elektronik yang terdiri dari gabungan dari ratusan, ribuan, bahkan jutaan transistor, resistor, dan kapasitor yang terintegrasi dalam sebuah sirkuit miniatur yang sangat kompleks. IC merupakan teknologi yang memungkinkan berbagai komponen elektronik disatukan menjadi satu chip kecil. IC pertama kali ditemukan pada tahun 1958 oleh Jack Kilby dari Texas Instruments dan Robert Noyce dari Fairchild Semiconductor. IC memiliki beberapa jenis, antara lain IC digital, IC linear, dan Mixed IC. Kelebihan IC antara lain ukurannya yang kecil, hemat energi, dan efisien dalam penggunaan ruang. Sedangkan kelemahan IC adalah sensitif terhadap suhu dan tegangan, serta sulit untuk diperbaiki jika terjadi kerusakan.

11. Apa inovasi terpenting komputer generasi ketiga?

Inovasi terpenting pada komputer generasi ketiga adalah pengembangan integrated circuit (IC) pada tahun 1958 oleh Jack Kilby dari Texas Instruments dan Robert Noyce dari Fairchild Semiconductor. IC merupakan kepingan kecil yang mampu menampung banyak komponen menjadi satu, sehingga membuat komputer pada generasi ketiga menjadi lebih kecil, cepat, dan murah. Selain itu, pada generasi ketiga juga dilakukan pengembangan memori inti magnetik yang mampu menyimpan data secara lebih efisien. Komputer generasi ketiga juga menampilkan inovasi baru seperti pemrosesan paralel dan sistem operasi yang lebih canggih. Hal ini membuat komputer generasi ketiga lebih efisien dalam penggunaan energi dan lebih cepat dalam pemrosesan data.

12. Berikan gambaran singkat tentang komputer generasi keempat. Bagaimana teknologinya lebih baik dari generasi sebelumnya?

Komputer generasi keempat, yang dimulai pada dasawarsa 1970-an, ditandai oleh penemuan MOSFET dan integrasi berskala besar yang membawa perkembangan ke komputer pribadi yang semakin kecil berkat mikroprosesor. Inovasi ini memungkinkan munculnya komputer rumahan, komputer meja, laptop, dan ponsel cerdas yang sangat fenomenal. Teknologi ini membuat komputer generasi keempat lebih baik dari generasi sebelumnya dengan kemampuan untuk menghasilkan komputer yang lebih kecil, portabel, dan efisien dalam penggunaan energi. Komputer generasi keempat membawa revolusi dalam teknologi komputer dengan memperkenalkan perangkat yang lebih mudah diakses oleh masyarakat umum dan memungkinkan integrasi teknologi yang lebih dalam ke dalam kehidupan sehari-hari.

13. Berapakah masa komputer generasi kelima dan bandingkan inovasi dari generasi sebelumnya?

Komputer generasi kelima adalah masa sekarang dan masa yang akan datang. Pada generasi kelima, komputer sudah mulai menggunakan standar PC dan teknologi yang lebih canggih seperti superkonduktor, ULSI, dan kecerdasan buatan (Artificial Intelligence / AI. Inovasi pada generasi kelima ini menjadikan tampilan visual pada komputer memiliki resolusi yang sangat tinggi dan tajam. Negara yang mempelopori sejarah perkembangan komputer pada generasi kelima adalah Jepang. Komputer generasi kelima juga memungkinkan integrasi teknologi yang lebih dalam ke dalam kehidupan sehari-hari, menjadikan komputer sebagai bagian tak terpisahkan dari kehidupan modern.

14. Apa perbedaan antara perangkat keras dan perangkat lunak?

a. Perangkat Keras (Hardware): Merupakan bagian fisik komputer yang dapat dilihat dan disentuh. Contohnya meliputi CPU, RAM, hardisk, keyboard, mouse, monitor, dan printer. Menyediakan fondasi fisik untuk komputer beroperasi.

b. Perangkat Lunak (Software): Merupakan serangkaian instruksi atau program yang digunakan untuk mengontrol dan mengoperasikan perangkat keras. Contohnya meliputi sistem operasi (Windows, macOS, Linux) dan aplikasi (Microsoft Word, Google Chrome). Memberikan instruksi kepada perangkat keras tentang apa yang harus dilakukan.
Perangkat keras dan perangkat lunak saling melengkapi dan bekerja bersama untuk menciptakan sistem komputer yang kompleks. Perangkat keras menyediakan fondasi fisik, sementara perangkat lunak memberikan instruksi dan fungsionalitas pada komputer. Analogi yang tepat adalah hubungan antara tubuh (perangkat keras) dan otak (perangkat lunak) manusia; tubuh menyediakan struktur dan kemampuan untuk bergerak, sedangkan otak mengendalikan tindakan.

15. Apa perbedaan antara perangkat lunak sistem dan perangkat lunak aplikasi?

Perangkat lunak sistem dan perangkat lunak aplikasi adalah dua jenis perangkat lunak yang berbeda. Perangkat lunak sistem adalah perangkat lunak yang digunakan untuk mengontrol dan mengoperasikan perangkat keras, seperti sistem operasi, driver perangkat keras, dan utilitas sistem. Sedangkan perangkat lunak aplikasi adalah perangkat lunak yang digunakan untuk melakukan tugas tertentu, seperti pengolah kata, pengolah gambar, dan permainan. Perbedaan utama antara keduanya adalah bahwa perangkat lunak sistem digunakan untuk mengontrol dan mengoperasikan perangkat keras, sedangkan perangkat lunak aplikasi digunakan untuk melakukan tugas tertentu. Perangkat lunak sistem biasanya diinstal pada saat pembelian komputer, sedangkan perangkat lunak aplikasi dapat diinstal setelah pembelian komputer.



_Tugas pertemuan pertama selesai_











**Tugas Sistem Operasi Pertemuan Kedua**





![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/Selma%20Diagram%20pertemuan%202.drawio%20(1).png?raw=true)

Berikut Penjelasan dari Diagram yang saya buat:

**POST (Power On Self Test):**
- Selama tahap POST, komputer melakukan pemeriksaan mandiri terhadap perangkat kerasnya.
- POST memastikan bahwa komponen seperti RAM, CPU, kartu grafis, dan perangkat penyimpanan berfungsi dengan baik.
- Jika ada masalah dengan perangkat keras, POST biasanya memberikan kode kesalahan atau bunyi bip yang mengindikasikan masalah tersebut.

**Bootloader:**
- Bootloader adalah program kecil yang berada pada sektor awal dari hard drive atau media penyimpanan lainnya.
- Tugas bootloader adalah mencari dan memuat sistem operasi yang akan dijalankan.
- Beberapa bootloader populer termasuk GRUB (Grand Unified Bootloader) untuk Linux dan NTLDR (New Technology Loader) atau BOOTMGR (Boot Manager) untuk Windows.

**Sistem Operasi:**
- Sistem operasi (SO) adalah perangkat lunak inti yang mengelola sumber daya perangkat keras dan menyediakan antarmuka antara pengguna dan komputer.
- Setelah dimuat ke dalam memori utama (RAM), sistem operasi mengambil kendali dan memulai eksekusi program.
- Sistem operasi bertanggung jawab atas manajemen memori, file, proses, dan perangkat.

**Desktop:**
- Desktop adalah antarmuka grafis pengguna pada sistem operasi, memberikan lingkungan visual tempat pengguna dapat berinteraksi dengan komputer.
- Pada desktop, pengguna dapat melihat ikon, memulai program, membuka file, dan melakukan berbagai tugas lainnya.
- Pengaturan desktop, seperti latar belakang dan tata letak ikon, dapat disesuaikan sesuai preferensi pengguna.

Semua langkah ini membentuk suatu proses yang kompleks namun terstruktur saat komputer menyala dan bersiap untuk digunakan. Dengan pemahaman yang lebih mendalam tentang setiap tahap, pengguna dapat memahami bagaimana komputer mereka beroperasi dan mengidentifikasi potensi masalah jika terjadi gangguan pada salah satu tahapan proses booting.

Booting adalah proses dimana sebuah komputer atau perangkat lunak komputer diaktifkan dan memuat sistem operasi atau perangkat lunak lainnya ke dalam memori. Ada beberapa jenis booting yang umum digunakan, termasuk:

1. **Cold Boot (Boot Dingin):**
   - Cold boot terjadi ketika komputer atau perangkat dinyalakan setelah sebelumnya dimatikan sepenuhnya.
   - Pada cold boot, semua perangkat keras dan perangkat lunak sistem diinisialisasi kembali.

2. **Warm Boot (Boot Hangat):**
   - Warm boot terjadi ketika komputer di-restart tanpa dimatikan sepenuhnya.
   - Pada warm boot, beberapa komponen sistem mungkin tetap dalam keadaan aktif, dan tidak seperti cold boot, proses inisialisasi penuh tidak terjadi.

3. **Remote Booting:**
   - Remote booting melibatkan booting dari sumber yang tidak berada di perangkat fisik yang sama.
   - Contohnya adalah booting melalui jaringan (network boot), di mana sistem operasi dimuat dari server jaringan ke komputer klien.

4. **Network Boot (Boot Jaringan):**
   - Booting melalui jaringan memungkinkan sebuah komputer untuk memuat sistem operasi atau perangkat lunak lainnya dari server jaringan, tanpa menggunakan media penyimpanan lokal.

5. **Dual Boot:**
   - Dual boot memungkinkan pengguna untuk menginstal dan menjalankan dua sistem operasi yang berbeda pada satu komputer.
   - Pada saat booting, pengguna dapat memilih sistem operasi mana yang ingin digunakan.

6. **Multi-Boot:**
   - Multi-boot mirip dengan dual boot, tetapi melibatkan lebih dari dua sistem operasi yang dapat dipilih pada saat booting.

7. **Live Boot:**
   - Live boot memungkinkan pengguna untuk menjalankan sistem operasi langsung dari media penyimpanan tanpa menginstalnya pada hard drive.
   - Umumnya digunakan untuk uji coba atau pemulihan sistem.

8. **Fast Boot:**
   - Fast boot adalah fitur yang dirancang untuk mempercepat proses booting dengan meminimalkan waktu inisialisasi perangkat keras.

Setiap jenis booting memiliki tujuan dan kegunaannya sendiri tergantung pada kebutuhan pengguna atau konfigurasi sistem yang diinginkan.


















**MENGINDENTIFIKASI LAPTOP MELALUI APLIKASI CPU-Z**



**Spesifikasi CPU**


![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/Spesifikasi%20CPU%20Selma%20Humayra.PNG?raw=true)


CPU: Tab ini menunjukkan informasi tentang prosesor, seperti nama, kode nama, kecepatan clock, jumlah inti, dan teknologi yang digunakan.

**Section Processor**

Name: Intel Core I5 6300U

Menampilkan nama dari processor yang digunakan pada laptop atau komputer.

Code Name: Skylake-U/Y

Menampilkan Code dari processor yang dipakai komputer atau laptop.

Max TDP:  15.0 Watt

Menyatakan power consumption, Artinya laptop atau komputer ini membutuhkan daya 15.0 Watt saat bekerja.

Package : Socket 1356 FCBGA

Menampilkan bahwa jenis socket pada processor laptop ini adalah Socket 1356 FCBGA.

Technology : 14 nm

Menampilkan Seberapa besar komponen yang digunakan.

Core VID : 0.641 V

Menampilkan tegangan listrik yang digunakan sekitar 0.641 Volt.

Spesification : Itel Core i5-6300U CPU @ 2.40 Ghz

Menampilkan Spesifikasi dari komputer atau laptop yang dipakai.

Family: 6

Menampikan generasi keberapa processor yang di gunakan.

Ext Family : 6

Menampilkan total family (keluarga) processor yang ada dalam komputer atau laptop.

Intruction : MMX, SSE, SSE2, SSE3, SSSE3, SSE4.2, EM64T, VT-X, AES, AVX, AVX2, FMA3, TSX

Menampilkan instruksi yang didukung dalam processor yang dipakai.

A. MMX : berhubungan dengan Integrasi VGA (yang mangatur tentang visual berupa gambar, grafik, dll). 
B. SSE : jenis – jenis instruksi algoritma atau perhitungan yang dapat dipahami processor. 
C. EM64T : teknologi yang meningkatkan platform server dan stasiun kerja dengan keterlayakan alamat 64 bit dan instruksi terkait. 
D. VT-x : dapat mengizinkan komputer untuk membuat mesin virtual. 

E. TSX:TSX menyediakan dukungan untuk transaksi memori, yang memungkinkan beberapa operasi memori untuk dijalankan sebagai satu kesatuan transaksi atomik. Ini dapat meningkatkan kinerja aplikasi yang menggunakan operasi memori bersamaan pada tingkat tinggi.

Section Clocks (Core #0)
Core Speed : 798.63 MHz

Mengetahui kecepatan satu core satuan dalam melakukan suatu perintah.

Multiplier: x 8.0 (4.0 - 30.0)

Mengatur lebar jalur transfer yang tersedia. Pengkali. Apabila processor banyak melakukan proses pada computer, maka multiplier meningkat. Sedangkan apabila processor sedikit melakukan proses pada computer, maka multiplier menurun dalam keadaan stabil.

Bus Speed: 99.83 MHz

Menampilkan kecepatan transfer data dan instruksi atau kecepatan BUS. Jumlah alur yang mampu dilaksanakan oleh sebuah pemproses dalam masa second. Satuan waktu ini diukur dalam unit juta arahan second yang disebut juga sebagai megahertz (MHz) atau juta kitaran second.

Cache

Cache memory adalah memory berukuran kecil berkecepatan tinggi yang berfungsi untuk menyimpan sementara instruksi dan/atau data (informasi) yang diperlukan oleh prosesor.

L1 Data: 2 x 32 KBytes 8-way
L1 inst.: 2 x 32 Kbytes 8-way
Level 2 : 2x 256 KBytes 4-way
Level 3: 3 Mbytes 12-way

keterangan:

- L1 : Trensfer data ke prosesor paling cepat karena letaknya paling dekat dengan prosesor.

- L2 : Transfer data ke proseror lebih lambat dari L1 karena posisinya lebih jauh dari prosesor.

- L3 : Transfer datanya paling lambat kerena jauh dari prosesor.

  **Spesifikasi Mainboard**

**Section Mainboard**


![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/mainboard.PNG?raw=true)


Manufacturer: Dell Inc.

Merupakan pembuat atau pabrik dari motherboard laptop ini.

Model: 0kk5D1 A00

Tipe dari Motherboard pada komputer atau laptop saya.

Bus Specs: PCI - Express 3.0 (8.0 gt/s)
Chipset: Intel Skylake-U Rev.08

Chipset yang digunakan adalah Intel, sedangkan Skylake-U Rev.08 merupakan tipe dari chipset yang digunakan. Secara fisik, chipset berupa sekumpulan IC kecil atau chips yang dirancang untuk bekerjasama dan memiliki fungsi-fungsi spesifik tertentu.


Southbridge: Intel Skylake-Y PCH Rev.21

Section BIOS
Brand: Dell Inc.
Version: 1.19.0
Date: 07/26/2020

Keterangan di atas merupakan tanggal pembuatan BIOS Graphic Interface dan versi laptop yang saya punya. 

Section Graphic Interface
Tidak di ketahui


**Spesifikasi Memory**


![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/Memory.PNG?raw=true)




General
Type: DDR4
Menampilkan tipe memori apa yang digunakan pada laptop atau komputer.

Size: 8 GBytes
Merupakan besaran memori yang terdapat pada laptop ini.

Channel # Single
Uncore Frequency 897.6 Mhz

Section Timings
DRAMA Frequency: 1064.5 Mhz
FSB:DRAMA - 3:32
CAS# Latency (CL): 15.0 clocks
Ras# to CAS # Delay (trCD): 15 clocks
RAS # precharger (tRP): 15 clocks
Cycle Time(tRFC): 374 clocks
Command Rate (CR): 1T

**Spesifikasi SPD**


![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/spd.PNG?raw=true)



Memory Slot Selection:
SLot #1 - DDR4
MOdule Manuf: SK Hynix
DRAMA Manuf: SK Hynix
Part Number: HMA81GS6AFR8N-UH
Serial Number: 3382F207

Informasi tersebut memberikan detail terkait produsen modul memori (SK Hynix), nomor model (HMA81GS6AFR8N-UH), dan nomor seri (3382F207) dari modul DDR4 yang dipasang pada slot memori #1 pada sistem komputer.


**Spesifikasi Graphics**



![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/graphic.PNG?raw=true)



Name: Intel, HD Graphics 520
Board Manuf: Dell
Revision: 7

**Tentang Bench milik saya**


![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/Bench.PNG?raw=true)



**Tentang 'About'**


![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/About.PNG?raw=true)



_Tugas Pertemuan Kedua Selesai_



**Tugas Sistem Operasi Pertemuan Ketiga**
![alt text](https://github.com/selmamajah/SysOP24-3123521021/blob/main/Selma%20Mindmapping%20tugas%20minggu%20ketiga.png?raw=true)


Perbedaan antara BIOS dan EFI (Extensible Firmware Interface) terletak pada arsitektur dan desain, bootloader, antarmuka pengguna, dukungan perangkat keras, dan kompatibilitas sistem operasi.

**Arsitektur dan Desain:**
- BIOS menggunakan arsitektur firmware yang tradisional dan terkadang terbatas dalam kemampuan dan fleksibilitasnya. Ini menggunakan MBR (Master Boot Record) untuk menyimpan informasi partisi.
- EFI dirancang dengan arsitektur yang lebih modern dan modular, menggunakan GPT (GUID Partition Table) untuk partisi. Ini memungkinkan dukungan untuk partisi yang lebih besar dan lebih banyak.

**Bootloader:**
- BIOS menggunakan bootloader yang terintegrasi dengan firmware dan terbatas pada bootloaders seperti GRUB atau LILO.
- EFI dapat menggunakan bootloader terpisah dari firmware dan mendukung bootloader seperti GRUB, rEFInd, atau Microsoft Boot Manager.

**Antarmuka Pengguna:**
- BIOS umumnya memiliki antarmuka pengguna sederhana dan terbatas, sering kali hanya dapat diakses melalui tombol khusus saat boot.
- EFI menyediakan antarmuka pengguna yang lebih canggih, sering kali dengan dukungan untuk mouse dan grafis. EFI Shell memungkinkan interaksi yang lebih kompleks.

**Dukungan Perangkat Keras:**
- BIOS terbatas dalam mendukung perangkat keras modern dan fitur canggih seperti booting dari disk berkapasitas besar atau keamanan boot yang tinggi.
- EFI lebih fleksibel dan mendukung perangkat keras modern dengan lebih baik, seperti boot dari disk berkapasitas besar dan keamanan boot berbasis UEFI Secure Boot.

**Kompatibilitas Sistem Operasi:**
- BIOS umumnya lebih terbatas dalam mendukung sistem operasi modern, terutama sistem operasi 64-bit.
- EFI lebih mendukung sistem operasi modern dan dapat bekerja dengan baik dengan sistem operasi 32-bit dan 64-bit.

Secara keseluruhan, EFI dianggap lebih canggih dan fleksibel daripada BIOS, dan banyak sistem modern mengadopsi EFI sebagai pengganti BIOS.

_Tugas Pertemuan Ketiga Selesai_

**Tugas-tugas Pertemuan Keempat**

_TUGAS 3_

**1. Buatlah presentasi langkah demi langkah tentang siklus CPU (fetch ,decode, execute) utk mengeksekusi sebuah program. Jelaskan juga peran dari Bahasa pemrograman dan compiler, begitu juga dengan peran dari Sistem Operasi. Gunakan referensi : [Video referensi 1](https://www.youtube.com/watch?v=Z5JC9Ve1sfI) dan [Video referensi 2](https://www.youtube.com/watch?v=jFDMZpkUWCw)**

1. Presentasi langkah-langkah tentang siklus
![NOMER 1 TUGAS 3 TT](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/5a816149-a6be-4676-ab59-9d63d50876f5)

Inisialiasi awal

Fetch
![INISIALISASI AWAL 1](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/b93f07e8-c057-41a7-862a-711efe69a545)

![INISIALISASI AWAL KEDUA](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/2c1a8320-5fa2-493c-bf69-c57474e436bb)

Decode
![INISIALISASI AWAL 2](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/6ca0d2e1-4a50-4946-9c83-92ef1bfe970a)

excute
![DECODE](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/f908e088-5b20-43b3-9ad1-a320ace78718)


Siklus ambil-decode-eksekusi CPU adalah proses dasar yang dilakukan oleh CPU dalam pengolahan instruksi dalam sebuah komputer. Proses ini melibatkan tiga langkah utama:

A. Fetch: CPU mengambil instruksi dari memori utama.
B. Decode: CPU melakukan decode instruksi untuk mencari tahu apa yang perlu dilakukan.
C. Execute: CPU melakukan operasi yang diperintahkan dalam instruksi tersebut

Peran dari bahasa pemrograman dan compiler dalam siklus ambil-decode-eksekusi CPU adalah untuk mempermudah programmer dalam menulis program dalam bahasa yang dapat dipahami oleh komputer. Bahasa pemrograman memungkinkan programmer untuk menulis program dalam bahasa tingkat tinggi, yang kemudian dapat diterjemahkan oleh compiler ke dalam bahasa yang dapat dipahami oleh CPU.

Compiler adalah software yang mengkonversi program yang ditulis dalam bahasa pemrograman ke dalam bahasa yang dapat dipahami oleh CPU. Compiler melakukan analisis leksikal, semantik, dan kebenaran logika program, serta melakukan optimalisasi kode untuk meningkatkan kinerja.

Sistem operasi memiliki peran penting dalam siklus ambil-decode-eksekusi CPU, sebagai pengatur jalan untuk CPU. Sistem operasi mengatur bagaimana CPU mengakses memori, mengatur prioritas proses, dan memastikan bahwa setiap proses mendapatkan waktu dan memori yang diperlukan. Sistem operasi juga menangani input-output dan memastikan bahwa setiap proses dapat mengakses perangkat keras seperti keyboard, mouse, dan monitor.


**2. Baca dan pahami rangkuman materi OS: [Materi Intro to OS-01](https://github.com/ferryastika/OS-01)**

Baik, saya sudah membaca dan memahami.

**3. Jalankan VM Debian anda, lalu lakukan clone https://github.com/ferryastika/flops-iops. Compile dan eksekusi sesuai petunjuk. Sesuiakan jumlah thread dengan jumlah CPU yang ada di VM Debianmu. Catat hasilnya dan jelaskan arti dari hasil ekskusi. Lakukan sebanyak 5 kali. Bandingkan hasilnya anatar temanmu. Buat Plot perbandinnya hasil untuk masing-masing PC di tiap kelompokmu. Analisa hasil percobaan tadi dan beri kesimpulan tentang IOPS dan FLOPS.**

Sebelum mencoba _Percobaan_, saya terlebih dahulu memasukkan git clone https://github.com/ferryastika/flops-iops

![WhatsApp Image 2024-03-16 at 23 58 13_e3837267](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/da491513-943f-466d-93aa-8a42e21e471f)
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/6730c4d3-d3d0-4de4-9b31-267c3fe8f7b1)

**BenchUtil**

Program untuk mengukur Kemampuan CPU dalam satuan IOPS and FLOPS.

**Build Binaries**
$make

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/a61ab66d-eece-4b2e-a71e-da8a347fc780)

Analisis: make digunakan untuk memulai proses kompilasi dan mengelola kumpulan aplikasi dan file dari kode sumber.

**Cleaning Old Build**
$make clean
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/b5cfa670-ea12-4d37-a828-7ca7ecc98c7d)

Analisis: make clean digunakan untuk menghapus semua file objek dan file eksekusi yang dihasilkan oleh proses kompilasi sebelumnya.

**Install Binaries**
  $ sudo make install
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/8a0fd97a-382b-4f43-b4f2-756724cc7b59)

Analisis: sudo make install digunakan untuk memulai proses instalasi program yang telah di-compile.

**Uninstall Binaries**
  $ sudo make uninstall
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/a9cb3dd3-043f-44ac-9c1e-1a9510e02bb1)

Analisis: sudo make uninstall adalah perintah yang digunakan untuk menghapus instalasi sebuah aplikasi yang dibangun dari sumber daya.


**Usage**
  $ iops32 $(nproc)
  $ iops64 $(nproc)
  $ flops32 $(nproc)
  $ flops64 $(nproc)

**iops32 iops64 flops32 flops64 pertama**

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/b5abda84-4c16-421a-a94a-0aa7ef0a7d1f)

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/b4099bfe-7bd5-4ddb-8d66-bdf4ad1c3af8)

**iops32 iops64 flops32 flops64 kedua**

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/097a8ee0-18c3-42bc-b74c-48835951b3ce)

**iops32 iops64 flops32 flops64 Ketiga**

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/b1e051a7-7e92-4d2a-ac31-bb08d72ebe7f)

**iops32 iops64 flops32 flops64 Keempat**

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/163b082b-8ccb-4e49-b116-31ae06204688)

**iops32 iops64 flops32 flops64 kelima**
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/efc7d2c0-835e-4749-be40-f1624bf7f8a4)
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/56e469a8-9cd9-4d82-9858-4d5fbbf33707)


Perbandingan dengan teman:
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/25559192-c943-40e9-b3a0-2bd785ae7df1)


Kesimpulan perbandingan:
Semakin besar iops milik cpu laptop maka semakin kencang dan tepat membaca satuan data dalam hitungan perdetik. Punya saya rata-ratanya besar maka memiliki performa CPU lebih baik.



**4. Apabila Debian VM mu masih belum terdapat packeage gcc, make dan git, lakukan instalasi dan catat setiap langkahnya!**

Berikut merupakan langkah-langkah yang saya lakukan sebelum mencoba floaps:

A. **su -l, File /etc/apt/sources.list, apt update**

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/46edd5f0-5f21-442f-b8e3-bdc19c7a6242)

Analisis:

**selma@debianSELMA: ~ sul -l**  merupakan perintah ke debian untuk memasukkan kita ke root.

**File /etc/apt/sources.list** adalah file konfigurasi yang digunakan oleh sistem Debian dan turunannya untuk menentukan sumber paket perangkat lunak yang akan diambil paket-paketnya. Ini adalah file penting karena menentukan dari mana sistem akan mengunduh dan menginstal paket-paket perangkat lunak. Ketika saya menjalankan perintah nano /etc/apt/sources.list, saya membuka file ini untuk diedit menggunakan editor teks nano.

Dengan menjalankan **apt update**, saya memastikan bahwa sistem saya memiliki informasi terbaru tentang paket-paket yang tersedia dari repositori yang ditentukan. Ini termasuk informasi seperti daftar paket yang tersedia, versi terbaru dari paket, dan metadata lainnya.

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/7e17be15-58ab-4db8-ac29-d77c27b3c79c)

Analisis: 
**root@debianSELMA: ~#apt upgrade** Perintah apt upgrade digunakan untuk meng-upgrade paket-paket yang sudah terinstal di sistem Debian ke versi terbaru yang tersedia dari repositori yang terdaftar. Ini adalah langkah yang penting dalam memastikan bahwa sistem saya selalu menggunakan versi terbaru dari perangkat lunak dengan fitur terbaru dan perbaikan keamanan.

B.   **apt install git**
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/e5b5d19f-c5cd-4464-93d5-a66c65cb5e2a)
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/a9b67738-ab74-48ed-974f-c5c0cffee3f8)


Analisis: **~# apt install git** apt install git di Debian adalah perintah untuk menginstal perangkat lunak Git menggunakan manajer paket APT (Advanced Package Tool). Git adalah sistem kontrol versi yang digunakan oleh pengembang perangkat lunak untuk mengelola kode sumber proyek mereka. Ini memungkinkan pengembang untuk melacak perubahan dalam kode, bekerja sama dengan tim, dan mengelola versi berbagai perangkat lunak.


C. apt install debian package
![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/87d9d566-5985-412e-825f-0c39113ed4a6)

Analisis: Dengan menggunakan perintah ini, saya dapat dengan mudah mengelola perangkat lunak pada sistem Debian milik saya, memastikan bahwa sistem debian di perangkat saya terus diperbarui dan dilengkapi dengan perangkat lunak yang diperlukan yaitu debian package.




**_Selesai._**


_Tugas 4_

**TUGAS PENDAHULUAN:**

Jawablah pertanyaan-pertanyaan di bawah ini :

1. Apa yang dimaksud redirection?

_jawab_
Redirection adalah fitur di shell Linux yang memungkinkan kita untuk mengarahkan input dan output dari suatu perintah ke file atau perangkat lain.

Berikut merupakan jenis-jenis Redirection:
Input redirection: Mengarahkan input dari suatu perintah ke file atau perangkat lain. Contohnya: command < file_input
Output redirection: Mengarahkan output dari suatu perintah ke file atau perangkat lain. Contohnya: command > file_output
Append redirection: Menambahkan output dari suatu perintah ke file yang sudah ada. Contohnya: command >> file_output

2. Apa yang dimaksud pipeline?

_jawab_
Pipeline adalah fitur di shell Linux yang memungkinkan Anda untuk menggabungkan beberapa perintah sehingga output dari satu perintah menjadi input untuk perintah berikutnya. Contoh: command1 | command2 | command3

3. Apa yang dimaksud perintah di bawah ini : echo, cat, more, sort, grep, wc, cut, uniq

_jawab_
echo: Mencetak teks ke layar.
cat: Menampilkan isi file ke layar.
more: Menampilkan file ke layar secara per halaman.
sort: Mengurutkan baris-baris file berdasarkan kolom tertentu.
grep: Mencari baris-baris file yang mengandung pola tertentu.
wc: Menghitung jumlah baris, kata, dan karakter dalam file.
cut: Memotong kolom tertentu dari baris-baris file.
uniq: Menghilangkan baris-baris duplikat dalam file.
Contoh Penggunaan: 
Menampilkan isi file data.txt dan menghitung jumlah barisnya: cat data.txt | wc -l
Mencari baris-baris dalam file data.txt yang mengandung kata "Indonesia" dan mengurutkannya berdasarkan kolom nama: cat data.txt | grep "Indonesia" | sort -k2
Memotong kolom pertama dan kedua dari file data.txt dan menampilkannya secara per halaman: cat data.txt | cut -d, -f1,2 | more

**Percobaan**

1. $ps

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/60b6bc50-310b-41d5-b7e1-1f4696c09249)

Analisis: ps: Menampilkan daftar proses yang dijalankan oleh pengguna saat ini pada terminal.


2. . $ cat
 hallo, apa khabar
 hallo, apa khabar
 exit dengan ^d
 exit dengan ^d
 [Ctrl-d]

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/7f594497-47b5-417f-8607-4b16f5d97fba)

Analisis: Perintah "cat" (singkatan dari "concatenate") pada sistem Debian  digunakan untuk menggabungkan dan menampilkan konten dari satu atau beberapa file teks secara berurutan. Meskipun namanya adalah "concatenate", perintah "cat" juga sering digunakan untuk menampilkan isi tunggal file.

3.  $ mkdir mydir
$ mkdir mydir  (Terdapat pesan error)

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/a2b11fce-805a-4d3a-99d0-d2a778101b91)

Analisis: Perintah mkdir digunakan di Debian untuk membuat direktori (penyimpanan) baru. 


**Percobaan 2 : Pembelokan (redirection)**

1.   $ cat 1> myfile.txt
 Ini adalah teks yang saya simpan ke file myfile.txt


![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/34b59fd1-bacf-494b-aee7-88a4b0b5ccc5)

Analisis: Saya membelokan output cat yaitu standart inputan dari keyboard manual saya ke file bernama "myfile.txt" nah, fungsi simbol > adalah membelokan dan menyimpan output saya di file tersebut.  

2.   $ cat 0< myfile.txt
 $ cat myfile.txt

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/0d049676-9a1f-464d-9505-2fbb886bca56)

Analisis: cat 0 < myfile.txt ini merupakan pembelokan output sedangkan cat myfile.txt adalah untuk menampilkan isi dari file myfile.txt ke dalam terminal. 

3.   $ mkdir mydir (Terdapat pesan error)
 $ mkdir mydir 2> myerror.txt
 $ cat myerror.txt

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/79aa4086-902a-49fa-8ec3-3cae0a040daf)

Analisis:

mkdir merupakan singkatan dari _make directory_ dan mydir merupakan nama  direktori, berarti disini kita akan membuat direction baru.  _(Terdapat pesan error)_ merupakan pertanda terjadinya kesalahan. Dengan menggunakan 2> kita mengarahkan output kesalahan ke file myerror.txt.

cat myerror.txt merupakan perintah untuk membaca file myerror dan menampilkannya di terminal.

4. $ ls filebaru (Terdapat pesan error)
 $ ls filebaru 2> out.txt
 $ cat out.txt
 $ ls filebaru 2> out.txt 2>&
 $ cat out.txt

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/ac2167fe-377f-4f7b-8480-6ce1e629e72e)

Analisis: perintah pertama, $ ls filebaru, mencoba untuk menampilkan isi dari direktori filebaru. terdapat pesan error, itu mungkin karena direktori dengan nama tersebut tidak ada di debian saya. $ls file baru 2> out.text merupakan pembelokan output filebaru 2 ke dalam out.txt untuk di tampilkan ke dalam terminal. 

$ cat out.txt merupakan perintah membaca isi out.txt untuk di tampilkan ke terminal. 

 $ ls filebaru 2> out.txt 2>&1 pada perintah ini akan lansung mendapatkan perintah error karena melihat direktori yang tidak tersedia, pada perintah ini juga tidak akan membuat file karena dilakukan pembelokan dan menyebabkan perintah sama seperti perintah melihat file yang tidak tersedia.

5. $ echo “mencoba menulis file” 1> baru
$ cat filebaru 2> baru 1>&
$ cat baru

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/c8ab8d8a-47b9-4180-addb-0eb9d0edfa73)

Analisis:
$ echo “mencoba menulis file” 1> baru: Perintah ini mencoba menuliskan teks "mencoba menulis file" ke dalam file bernama baru. Namun, karena kesalahan penulisan, karakter kutip yang digunakan bukanlah karakter yang valid (yang seharusnya adalah ' atau "), sehingga mungkin menyebabkan masalah saat dieksekusi. Selain itu, penggunaan 1> tidak diperlukan dalam konteks ini karena echo secara default menulis ke stdout.

$ cat filebaru 2> baru 1>&: Perintah ini mencoba menampilkan isi dari file filebaru, mengarahkan output kesalahan ke file baru, dan kemudian mengarahkan output standar (stdout) ke suatu tempat yang tidak jelas karena tanda & setelah 1>& tidak diikuti oleh nomor file descriptor atau tujuan yang jelas.

$ cat baru: Ini mencoba menampilkan isi dari file baru.

6.  $ echo “kata pertama” > surat
$ echo “kata kedua” >> surat
$ echo “kata ketiga” >> surat
$ cat surat
$ echo “kata keempat” > surat
$ cat surat

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/c7f1d18b-2974-4326-9420-cad29ea0a641)

Analisis: $ echo “kata pertama” > surat: Perintah ini menulis teks "kata pertama" ke dalam file bernama surat. Karena penggunaan operator > memang untuk membelokkan output ke suatu tempat.

$ echo “kata kedua” >> surat: Perintah ini menambahkan teks "kata kedua" ke dalam file surat tanpa menghapus atau mengganti konten yang ada. Ini dilakukan dengan menggunakan operator >>, yang berarti "menambahkan ke akhir file". Jadi, teks "kata kedua" akan ditambahkan sebagai baris kedua di file surat.

$ echo “kata ketiga” >> surat: Perintah ini juga menambahkan teks "kata ketiga" ke dalam file surat sebagai baris baru ketiga, tanpa menghapus atau mengganti konten yang sudah ada sebelumnya.

$ cat surat: Ini akan menampilkan isi dari file surat di terminal.


7. $ cat <<++
Hallo, apa kabar?
Baik-baik saja?
Ok!
++
$ cat <<%%%
Hallo, apa kabar?
Baik-baik saja?
Ok!
%%%

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/d809f3dd-98e4-43d8-b904-d704f9640aab)

Analisis: Perintah cat <<+ (atau cat <<%%%) adalah contoh dari penggunaan heredoc di shell. Heredoc adalah cara untuk menetapkan teks multibaris ke dalam variabel atau langsung menampilkan teks tersebut di terminal.



8.  $ cat myfile.txt – surat

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/d81a2b39-efee-4f1f-9a84-0db69e904eb7)
Analisis: 

Perintah cat myfile.txt - surat dalam terminal Linux (termasuk Debian) merupakan contoh penggunaan perintah cat untuk menggabungkan isi dari dua atau lebih file ke dalam satu output yang ditampilkan di terminal.


**Percobaan 3 : Pipa (pipeline)**

1. $ who
$ who | sort
$ who | sort –r
$ who > tmp
$ sort tmp
$ rm tmp
$ ls –l /etc | more
$ ls –l /etc | sort | more

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/91e45b55-d0de-4eae-88bc-af39ebefa08c)

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/e13e8806-432a-44e4-80a5-b4c524a22cee)

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/8fa5da86-3151-44f6-ad81-626ace5090a0)

Analisis: 

Perintah $who di Debian (dan di distribusi Linux lainnya) digunakan untuk menampilkan informasi tentang pengguna yang saat ini login ke sistem. Ini termasuk nama pengguna, terminal atau lokasi di mana mereka login, waktu login, dan informasi tambahan seperti IP address jika mereka login melalui jaringan. Perintah ini juga dapat menampilkan pengguna yang login melalui terminal virtual, seperti pengguna yang login melalui SSH. Itu adalah salah satu dari beberapa perintah yang digunakan untuk memantau aktivitas pengguna pada sistem Linux.

2.  $ echo hello
$ echo hello > output
$ cat output

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/0ba794e9-5cb6-43c2-b733-8b1eb167d6b6)

Analisis: 

$ echo hello: Perintah ini akan menampilkan teks "hello" ke terminal.

$ echo hello > output: Perintah ini akan mengarahkan output dari perintah echo hello ke dalam file bernama "output". Dengan demikian, teks "hello" akan dituliskan ke dalam file "output" dan tidak akan ditampilkan di terminal.

$ cat output: Perintah ini digunakan untuk menampilkan isi dari file "output". Oleh karena itu, ketika saya menjalankan perintah ini, teks "hello" yang sebelumnya telah dituliskan ke dalam file "output" akan ditampilkan di terminal.

3.  $ echo bye >> output
$ cat output

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/75d0b411-8899-47d4-9a34-35d3df7a6c8a)

Analisis: sebelumnya ada file bernama output yang berisi kata hello, nah, saya mau memasukkan kata baru yaitu bye di file output tampa menghapus kata hello itu dengan memakai tanda >> alhasil tanda tersebut membuat kalimat tambahannya berada di bawah kalimat hello.

4.  $ cat < output

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/f1f6746f-4c00-4669-9beb-8250a8887657)

Analisis: 

Tanda < yang diikuti oleh nama file "output" mengindikasikan bahwa input untuk perintah cat diambil dari file "output".
Dengan demikian, cat membaca isi dari file "output" dan menampilkannya di terminal.

5. $ cat < output > out
$ cat out
$ cat < output >> out
$ cat out
$ cat < output > output
$ cat output
$ cat < out >> out (Proses tidak berhenti)
[Ctrl-c]
$ cat out

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/c6f70666-454e-4514-8fb4-a8e921d7e0b4)

Analisis: $ cat < output > out: Perintah ini mengarahkan isi dari file "output" ke perintah `cat` dan kemudian menulisnya ke dalam file "out".

$ cat out: Perintah ini menampilkan isi dari file "out". Setelah langkah pertama, "out" sekarang berisi konten yang sama dengan file "output".

`$ cat < output >> out: Perintah ini mengarahkan kembali isi dari file "output" ke perintah `cat`, dan kemudian menambahkannya ke dalam file "out" yang sudah ada sebelumnya. Jadi, konten dari "output" ditambahkan ke akhir konten yang sudah ada dalam "out".

$ cat out: Perintah ini kembali menampilkan isi dari file "out". Sekarang, "out" berisi dua kali lipat konten yang sama dari "output", karena langkah sebelumnya menambahkan konten baru ke dalamnya.

$ cat < output > output: Perintah ini mengarahkan isi dari file "output" ke dalam file "output" itu sendiri. Ini akan menghasilkan file kosong, karena saat Anda menulis isi "output" ke "output", file "output" akan ditimpa dan menjadi kosong.

$ cat output: Perintah ini menampilkan isi dari file "output". Karena langkah sebelumnya telah menimpa isi "output" dengan file kosong, maka tidak akan ada konten yang ditampilkan.

$ cat < out >> out: Perintah ini mencoba untuk mengarahkan kembali isi dari file "out" ke perintah `cat`, kemudian menambahkannya ke dalam file "out" itu sendiri. Namun, langkah ini memicu sebuah loop tak terbatas, karena setiap kali Anda menambahkan isi "out" ke "out", ukurannya akan terus bertambah dan menyebabkan loop tak terbatas.

Pada akhirnya, saya memutuskan proses dengan menekan `Ctrl-c`. Setelah itu, saya ingin menganalisis konten dari file "out". Namun, karena langkah terakhir menyebabkan loop tak terbatas, konten "out" mungkin sangat besar dan sulit dianalisis.

---------

**Percobaan 4: Filter**

1.  $ w –h | grep <user>
 $ grep <user> /etc/passwd
 $ ls /etc | wc
 $ ls /etc | wc –l
 $ cat > kelas1.txt
 Badu
 Zulkifli
 Yulizir
 Yudi
 Ade
 [Ctrl-d]
 $ cat > kelas2.txt
 Budi
 Gama
 Asep
 Muchlis
 [Ctrl-d]
 $ cat kelas1.txt kelas2.txt | sort
 $ cat kelas1.txt kelas2.txt > kelas.txt
 $ cat kelas.txt | sort | uniq


![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/9c68dcb6-35b0-45e3-b691-ba4ec247d9b9)

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/dac9e10c-261d-498b-9fcf-6b66fc05406c)

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/58fdaa18-8756-4cf1-8097-d8cf44bf5895)

**Latihan**

1.  Lihat daftar secara lengkap pada direktori aktif, belokkan tampilan standard output ke file baru.

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/527fedb3-a585-4520-bac0-c781722f6454)

2. Lihat daftar secara lengkap pada direktori /etc/passwd, belokkan tampilan standard output ke file baru tanpa menghapus file baru sebelumnya.

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/bf0301f3-ac7e-464a-ae85-06c77bb762fa)

3. Urutkan file baru dengan cara membelokkan standard input.

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/7707710b-f39c-43bd-819d-9dfc03276dc2)


4. Urutkan file baru dengan cara membelokkan standard input dan standard output ke file baru.urut.

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/e46062ec-07b6-4058-b712-3f8c3aa4e5a3)

5. Buatlah direktori latihan 2 sebanyak 2 kali dan belokkan standard error ke file rmdirerror.txt.

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/734654e2-d5bc-4247-bae0-18379752889c)

6. Urutkan kalimat berikut :

Jakarta
Bandung
Surabaya
Padang
Palembang
Lampung

Dengan menggunakan notasi here document (<@@@ ...@@@)

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/7d4fabd9-0213-4ff3-95ad-e26a33a50384)

7. Hitung jumlah baris, kata dan karakter dari file baru.urut dengan menggunakan filter dan tambahkan data tersebut ke file baru.

8. Gunakan perintah di bawah ini dan perhatikan hasilnya.
 $ cat > hello.txt
 dog cat
 cat duck
 dog chicken
 chicken duck
 chicken cat
 dog duck
 [Ctrl-d]
 $ cat hello.txt | sort | uniq
 $ cat hello.txt | grep “dog” | grep –v “cat”

![image](https://github.com/selmamajah/SysOP24-3123521021/assets/148773260/c4414c6c-e425-4889-9a25-c8bc28504b0e)


_Tugas tiga dan tugas empat di pertemuan keempat selesai_








